---
title: "Vivaldi vignette"
output:
  html_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This notebook demonstrates the use of the package *vivaldi* to analyze viral single nucleotide variants from Illumina sequencing.  The *vivaldi* package provides tools for visualizing and summarizing allele frequency information, and genetic diversity, in heterogeneous viral genomes.  

This vignette takes variant data in the form of VCF files generated using the [MAD2](https://github.com/gencorefacility/MAD2) genome alignment and variation calling pipeline.  The vcf files are generated using the variant callers *timo* and *iVar*; however, the functions are designed to work with all variant callers. 

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Load the Vivaldi pacakge

The **vivaldi** package is available on CRAN and is loaded as follows.  We also load *kableExtra* for rendering tables in vignette 
```{r setup}
library(vivaldi)
library(kableExtra)
```

## Vignette data set
The data used in this vignette are simulated influenza genomes with specified variants at random frequencies. The VCF files have been annotated using *SNPeff* before running *Vivaldi*. 

# Step 1: Set path for variant data and metadata

The data used in this vignette is included with the package. To run your own data, users should set the path to those files. 

```{r}
vardir = system.file("extdata", "vcfs", package="vivaldi") 
```

Metadata used for the calculations includes a `.csv` file containing the length of each of the viral segments. For non-segmented viruses, simply report the whole length of the genome. Users should also set a variable with the total length of the viral genome (i.e. the sum of the segment lengths). 

```{r}
seg_sizes = system.file("extdata", "SegmentSize.csv", package="vivaldi")
sizes = read.csv(file=seg_sizes,header=T,sep=",",na.strings = c(''))
genome_size = 13133
```

The user should also supply a `.csv` file with sample information containing 3 columns:
* the unique name of each VCF file 
* which unique replicate number for the sample  
* the sample name to be used for the merged replicate data 

```{r}
rep_info = system.file("extdata", "reps.csv", package="vivaldi")
replicates = read.csv(file = rep_info, header = T, sep = ",", na.strings = c(""))
head(replicates)
```

# Step 2: Loading data and arranging 

## Load VCF files into a dataframe

The first step is performed using `arrange_data()` to load the VCF files into R, extract the important information. and arrange data as a tidy dataframe. The dataframe contains the sample name, pulled from the VCF file name, and information about the reference and alternative allele. If the VCF has not previously been annotated by SNPeff (recommended), the user should specify `annotated = "no"`. 

```{r message=FALSE, warning=FALSE}
VCF_DF = arrange_data(vardir, ref = system.file("extdata", "H1N1.fa", package="vivaldi"), annotated = 'yes')
kable(head(VCF_DF))
dim(VCF_DF)
```

The VCF_DF dataframe  contains all variants from all of the files. The columns are:

* sample: sample name (pulled from VCF file name)
* CHROM: segment the variant was found on
* POS: nucleotide position of the variant
* REF: nucleotide found at this position in the reference genome used for alignment ("ref = ")
* ALT: nucleotide found at this position in the sample 
* ANN: annotation information from SNPeff, not yet formatted 
* gt_DP: total number of reads (i.e. depth) that cover this position
* REF_COUNT: number of reads that include the REF nucleotide
* ALT_COUNT: number of reads that include the ALT nucleotide
* REF_FREQ: frequency of the reference nucleotide, calculated using REF_COUNT / gt_DP
* ALT_FREQ: frequency of the alternate nucleotide, calculated using ALT_COUNT / gt_DP
* ALT_TYPE: categorization of the alternate nucleotide. If found at frequencies > 50%, it is labelled as major; if found at frequencies < 50%, it is labelled as minor.
* major: major nucleotide
* minor: minor nucleotide
* majorcount: number of reads containing the major nucleotide
* minorcount: number of reads containing the minor nucleotide
* majorfreq: frequency of the major nucleotide
* minorfreq: frequency of the minor nucleotide

If working with a segmented genome, users should provide a vector containing the segments in the desired order for plotting.

```{r}
SEGMENTS = c("H1N1_PB2","H1N1_PB1","H1N1_PA","H1N1_HA","H1N1_NP","H1N1_NA","H1N1_MP","H1N1_NS")
VCF_DF$CHROM = factor(VCF_DF$CHROM, levels = SEGMENTS)
```

## Merging Replicate Sequence Data

Performing technical replicates of library preparation and DNA sequencing improves the accuracy of variant calling as sequencing or RT-PCR errors are unlikely to occur at the same site in independent experiments. 

For this function, the user must provide the variant dataframe (output of the `arrange_data() function`) and the replicates dataframe. Additional information that is required is:
* the name used for replicates 1 and 2 from the replicates dataframe (ex. "Rep1", "r1", "rep1", etc), which must be provided in quotes
* a vector containing the names of the columns that should be used to merge the two dataframes.  This vector must contain columns that are identical between the two replicates, such as the segment and nucleotide position of the variant. It should not contain replicate-specific information such as the allele frequency of the variant.

The `merge_replicates()` functions generates a dataframe with variants that are found in both sequencing replicates. It excludes variants that are only found in one replicate

```{r}
cols = c("sample","CHROM","POS","REF","ALT","ANN","ALT_TYPE","major","minor")

DF_reps = merge_replicates(VCF_DF,replicates,"rep1","rep2",cols)
```

### Compare the allele frequencies between replicate 1 and 2

Visual analysis of the variation in allele frequency estimations from the two sequencing experiments is informative about the technical variation.

```{r}
ggplot2::ggplot(DF_reps, ggplot2::aes(x = minorfreq.x, y = minorfreq.y)) + 
  ggplot2::geom_point()
```

### Compare the similarity between the average allele frequency and the weighted average allele frequency

`merge_replicates()` calculates two average allele frequency values both the average allele frequency, as well as the weighted average allele frequency, for the major and minor allele. 
* The **average** is calculated by simply taking the mean of the allele frequency estimates from both replicates. 
* The **weighted average** is calculated by adding the number of reads containing either the major or minor nucleotide from both replicates and dividing by the total number of reads. 

The average and the weighted average should be similar unless one of the replicates has significantly higher coverage per sample than the other.

```{r}
ggplot2::ggplot(DF_reps, ggplot2::aes(x = minorfreq, y = weighted_minorfreq)) + ggplot2::geom_point()
```

DAVID HAS STOPPED HERE ON THURSDAY NOVEMBER 10

## Filter out variants based on coverage and/or frequency cutoffs
This function filters the variants by frequency or coverage of the ALT allele. Based on a benchmarking study performed by our lab (https://www.biorxiv.org/content/10.1101/2021.05.05.442873v2), we recommend 1% allele frequency and no coverage cutoff for sequencing data with replicates. For sequencing data without replicates, a much more stringent filtering step is recommended to ensure confidence in the variants called. We suggest a 3% allele frequency and 200X coverage for data without replicates. If data includes replicates, the function checks to make sure each replicate passes the cutoffs. 
```{r}
# Use default coverage (200) and frequency (0.03) cutoffs 
DF_filt = filter_variants(DF_reps)

# To run with custom values, specify these in the function
kable(head(DF_filt,coverage_cutoff = 400, freq_cutoff = 0.02))
dim(DF_filt)
```

## Format SNPeff information
This function takes the one large annotation column containing annotation information from SNPeff and separates them out into individual columns with one attribute each.
```{r}
DF_filt = prepare_annotations(DF_filt)

kable(head(DF_filt))
dim(DF_filt)
```

## Add metadata
Here, we add in information about the sizes of the segments, which will allow us to do downstream calculations like tstv, dNdS, and others. The user must provide both the variant dataframe and the loaded metadata dataframe, as well as the names of the columns to merge by in both. 
```{r}
DF_filt = add_metadata(DF_filt, sizes, c('CHROM'), c('segment'))

kable(head(DF_filt))
dim(DF_filt)
```

# Step 3: Calculations & Generating plots

## Plot distribution of all minor variant frequencies
This function takes the variant dataframe and generates a plot showing the distribution of the the minor variants (appearing in less than 50% of the reads for any sample). For many viruses, we expect the distribution to be skewed to very low frequency variants (< 10%). 
```{r}
af_distribution(DF_filt)
```

## Count number of SNVs
The function tally_it() allows the user to count the number of variants over a given set of variables. These variables should be provided as a vector and then passed into the function in addition to the name, in quotes, for the new column containing the number of variants. For example, to get the sum of variants on every segment, the user should construct a vector containing the name of the sample column and the name of the segment column and pass that list into the function. 
```{r}
group_list_seg = c('sample','CHROM', "SegmentSize")
seg_count = tally_it(DF_filt, group_list_seg, "snv_count")

kable(head(seg_count))


# Alternatively, to count across genomes:
group_list_gen = c('sample')
gen_count = tally_it(DF_filt, group_list_gen, "snv_count")

kable(head(gen_count))
```

## Plot location of SNVs across segments
This function takes the variant dataframe and generates a large, interactive plot of all of the variants. The plot will be faceted by each segment for each individual sample. The user can scroll over each point in the plot to get information about that variant, including the nucleotide change and the position on the segment.
```{r}
snv_location(DF_filt)
```

## Plot number of SNVs per sample and per segment
The snv_genome() function will take the variant dataframe and generate a plot of the number of variants per genome and colors them by their SNPeff annotation, while the snv_segment() function will generate the same plot but faceted by segment. 
```{r}
snv_genome(DF_filt)
snv_segment(DF_filt)
```

## Calculate Transition/Transversion Ratio 
The transition/transversion ratio is commonly used to test for a bias in nucleotide conversions. Transitions are expected to be more common. Here, the user must provide the variant dataframe and the length of the genome, as this ratio will be calculated by segment and over the whole genome. 
```{r}
DF_tstv = tstv_ratio(DF_filt,genome_size)
kable(head(DF_tstv))
```

## Plot TsTv
This function will take the variant dataframe and generates 3 plots: the Ts/Tv ratio across the genome, the ratio across each segment, and the ratio across each segment normalized by kilobase. 
```{r}
tstv_plot(DF_tstv)
```

## Calculate Shannon entropy
Shannon entropy is a commonly used metric to describe the amount of genetic diversity in sequencing data. It is calculated by considering the frequency of the ALT and REF allele at every position and then summing those values over either a segment or over the entire genome. These values can then be normalized by kb in order to compare across different segments or samples. As a result, this function outputs a dataframe with five new columns reflecting these different calculations. The user must provide the variant dataframe and the length of the genome they are working with. 
```{r}
DF_filt = shannon_entropy(DF_filt,genome_size)

kable(head(DF_filt))
dim(DF_filt)
```

## Plot shannon entropy per sample and per segment
This function takes the variant dataframe and generates three plots. The first plot reports the Shannon entropy, or amount of diversity, at each position in the genome at which a variant was found. These values are then summed over each segment - plot 2 - and each genome - plot 3 - in order to compare between samples. A higher value indicates more diversity. 
```{r}
# makes 3 plots
plot_shannon(DF_filt)
```


## Calculate dNdS ratio and plot per sample per protein product
The dN/dS ratio is commonly used to test for a bias in amino acid conversions. dN counts the number of nonsynonymous mutations per nonsynonymous sites, or nucleotide changes that result in an amino acid change in the resulting protein product. dS counts the number of synonymous mutations per synonymous sites, which don't result in an amino acid change and are not expected to be under strong selection. Under neutral evolution, the dN/dS is expected to be approx. equal to 1, while a ratio > 1 indicates an enrichment of nonsynonymous changes, a hallmark of positive selection, and a ratio < 1 indicates a depletion of nonsynonymous changes, a hallmark of negative or purifying selection. The user must provide the variant dataframe that contains information about the amino acid changes for all nucleotide variants, otherwise this metric will not accurately reflect the true value.  
```{r}
##dNdS_segment ## SAYS NEEDS dataframe - must be for amino-acid specific calculations, cannot be the same as the dataframe used for SNP calculations
SPLICEFORMS = c("H1N1_PB2.1", "H1N1_PB1.1", "H1N1_PA.1", "H1N1_HA.1" ,"H1N1_NP.1", "H1N1_NA.1", 
                "H1N1_M1.1", "H1N1_M1.2", "H1N1_NS.1", "H1N1_NS.2")
dNdS_segment(DF_filt)
```

## Determine if variants are shared among samples
This function takes the variant dataframe and generates a plot that annotates the variants based on the number of times it appears in independent samples. The darker the color of the point, the more samples that variant is found in. Depending on the context of the user's experimental design, a variant that is found in many samples could be an indication of convergent evolution and would potentially be a good starting point for deeper investigation. 
```{r}
shared_snv_plot(DF_filt)

# Alternatively, to compare only a select number of samples, provide a character vector with their names
shared_snv_plot(DF_filt, samples = c("a_1_fb","a_1_iv"))
```

By default, this plot asks if the variant is shared across all samples. To specify only a subset of samples to compare, pass the names of those samples into the function, which will tell the function to pull only those samples before tallying. 


## Print dataframe of variants shared among samples for further analysis
This function takes the variant dataframe and creates a new table, listing the variants in descending order of how many samples they are found in. This function is meant to simplify further investigation of visual patterns in the previous plot. 
```{r}
shared_snv_table(DF_filt)
```

## Isolate variant of interest and plot AF at that position in all samples
This function allows users to focus on a single variant of interest and track the allele frequency of the major and the minor allele in all samples it is found in. To run, the user must provide the variant dataframe and the segment name and nucleotide position, in quotes, of the variant they are interested in. This can be run for any variant found in the sequencing data. 
```{r}
# provide the df, segment, and variant position
position_allele_freq(DF_filt,"H1N1_HA", "1007")
```

This function is particularly useful to identify changes in allele frequency over time, if working with time series data, or between individuals in a transmission chain. If a variant is seen to rise in frequency over time, that is a potential indication of positive selection. If a variant is transmitted between individuals, it may also indicate some functional advantage. However, as transmission bottlenecks are thought to be relatively narrow for most viruses, a variant's presence may also simply indicate a variant "lucky" enough to become part of the founding population for the next infection. 
